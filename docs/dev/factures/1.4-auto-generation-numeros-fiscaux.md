# Module 1.4 : Auto-g√©n√©ration Num√©ros Fiscaux

## üìã Vue d'ensemble

Ce module documente le syst√®me d'auto-g√©n√©ration des num√©ros de factures dans le Dashboard Madinia. Il couvre le format `FACT-2025-{numero}` s√©quentiel, la m√©thode `genererNumeroFacture()`, les contraintes fiscales d'unicit√© et les migrations des formats existants.

## üî¢ Format de Num√©rotation Fiscal

### Structure Standard FACT-YYYY-NNNN

```php
// Format officiel des num√©ros de facture
// FACT-2025-0001, FACT-2025-0002, etc.

const FORMAT_NUMERO_FACTURE = 'FACT-{ANNEE}-{NUMERO_SEQUENCE}';

// Exemples de num√©ros g√©n√©r√©s :
// FACT-2025-0001  // Premi√®re facture de 2025
// FACT-2025-0002  // Deuxi√®me facture de 2025
// FACT-2025-0150  // 150√®me facture de 2025
// FACT-2026-0001  // Premi√®re facture de 2026 (reset compteur)
```

### Diff√©rences avec la Num√©rotation Devis

| **Aspect** | **Devis** | **Factures** |
|------------|-----------|--------------|
| **Pr√©fixe** | `DV` | `FACT` |
| **Format** | `DV-25-{ID}` | `FACT-2025-{SEQ}` |
| **Ann√©e** | Abr√©g√©e (25) | Compl√®te (2025) |
| **Num√©rotation** | Bas√©e sur ID | S√©quentielle par ann√©e |
| **Reset annuel** | Non | Oui (recommenc√© √† 0001) |
| **Conformit√©** | Interne | Fiscale (obligatoire) |

### Avantages du Format S√©quentiel

```mermaid
graph TD
    A[Num√©rotation S√©quentielle FACT-YYYY-NNNN] --> B[Conformit√© Fiscale]
    A --> C[Tra√ßabilit√© Chronologique]
    A --> D[Unicit√© Garantie]
    A --> E[Comptabilit√© Simplifi√©e]
    
    B --> B1[Respect Code G√©n√©ral des Imp√¥ts]
    B --> B2[Contr√¥les Urssaf]
    B --> B3[Audits Comptables]
    
    C --> C1[Ordre Chronologique Strict]
    C --> C2[D√©tection Trous Num√©rotation]
    C --> C3[Historique par Ann√©e]
    
    D --> D1[Contrainte UNIQUE en DB]
    D --> D2[Impossible Doublons]
    D --> D3[G√©n√©ration Atomique]
    
    E --> E1[Export Sage/EBP]
    E --> E2[D√©clarations TVA]
    E --> E3[Bilan Annuel]
```

## üõ†Ô∏è M√©thode genererNumeroFacture()

### Impl√©mentation Compl√®te

```php
/**
 * G√©n√©rer automatiquement un num√©ro de facture s√©quentiel
 * Format : FACT-YYYY-NNNN (ex: FACT-2025-0001)
 * 
 * @param int|null $annee Ann√©e sp√©cifique (par d√©faut ann√©e courante)
 * @return string Num√©ro de facture unique
 * @throws \Exception Si impossible de g√©n√©rer un num√©ro
 */
public static function genererNumeroFacture(?int $annee = null): string
{
    $annee = $annee ?? date('Y');
    
    // =======================================
    // PHASE 1 : REQU√äTE ATOMIQUE S√âCURIS√âE
    // =======================================
    
    // Utilisation de DB::transaction pour √©viter les conditions de course
    return DB::transaction(function () use ($annee) {
        
        // Recherche du dernier num√©ro de l'ann√©e avec verrouillage
        $dernierNumero = static::where('numero_facture', 'LIKE', "FACT-{$annee}-%")
                              ->lockForUpdate()  // Verrouillage pessimiste
                              ->orderBy('numero_facture', 'desc')
                              ->first();
        
        // =======================================
        // PHASE 2 : CALCUL DU PROCHAIN NUM√âRO
        // =======================================
        
        if ($dernierNumero) {
            // Extraction du num√©ro s√©quentiel depuis le format FACT-YYYY-NNNN
            $dernierSequence = (int) substr($dernierNumero->numero_facture, -4);
            $nouveauSequence = $dernierSequence + 1;
            
            // Validation de la limite th√©orique (9999 factures/an)
            if ($nouveauSequence > 9999) {
                throw new \Exception(
                    "Limite de 9999 factures par ann√©e atteinte pour {$annee}. " .
                    "Veuillez passer √† l'ann√©e suivante ou modifier le format."
                );
            }
        } else {
            // Premi√®re facture de l'ann√©e
            $nouveauSequence = 1;
        }
        
        // =======================================
        // PHASE 3 : FORMATAGE FINAL
        // =======================================
        
        $numeroGenere = sprintf('FACT-%d-%04d', $annee, $nouveauSequence);
        
        // =======================================
        // PHASE 4 : VALIDATION D'UNICIT√â
        // =======================================
        
        // V√©rification finale (s√©curit√© suppl√©mentaire)
        $existe = static::where('numero_facture', $numeroGenere)->exists();
        if ($existe) {
            throw new \Exception(
                "Conflit de num√©rotation d√©tect√© : {$numeroGenere} existe d√©j√†. " .
                "Veuillez r√©essayer."
            );
        }
        
        return $numeroGenere;
    });
}
```

### Gestion des Cas d'Erreur

```php
/**
 * Version robuste avec gestion d'erreurs et retry automatique
 */
public static function genererNumeroFactureRobuste(?int $annee = null, int $maxTentatives = 3): string
{
    $tentative = 0;
    $derniereErreur = null;
    
    while ($tentative < $maxTentatives) {
        try {
            return static::genererNumeroFacture($annee);
            
        } catch (\Exception $e) {
            $tentative++;
            $derniereErreur = $e;
            
            // Log de l'erreur
            Log::warning("√âchec g√©n√©ration num√©ro facture (tentative {$tentative}/{$maxTentatives})", [
                'error' => $e->getMessage(),
                'annee' => $annee ?? date('Y'),
                'trace' => $e->getTraceAsString()
            ]);
            
            // D√©lai avant retry (√©viter les collisions)
            if ($tentative < $maxTentatives) {
                usleep(rand(100000, 500000)); // 100-500ms al√©atoire
            }
        }
    }
    
    // √âchec d√©finitif apr√®s toutes les tentatives
    throw new \Exception(
        "Impossible de g√©n√©rer un num√©ro de facture apr√®s {$maxTentatives} tentatives. " .
        "Derni√®re erreur : " . $derniereErreur->getMessage()
    );
}
```

### Hook d'Auto-g√©n√©ration

```php
// Dans le mod√®le Facture.php - √©v√©nement creating()
protected static function boot()
{
    parent::boot();
    
    // Auto-g√©n√©ration du num√©ro si absent lors de la cr√©ation
    static::creating(function ($facture) {
        if (empty($facture->numero_facture)) {
            try {
                $facture->numero_facture = static::genererNumeroFactureRobuste();
                
                Log::info("Num√©ro facture auto-g√©n√©r√©", [
                    'numero_genere' => $facture->numero_facture,
                    'client_id' => $facture->client_id,
                    'method' => 'auto_generation_creating'
                ]);
                
            } catch (\Exception $e) {
                Log::error("√âchec auto-g√©n√©ration num√©ro facture", [
                    'error' => $e->getMessage(),
                    'client_id' => $facture->client_id
                ]);
                
                // Re-lancer l'exception pour emp√™cher la cr√©ation
                throw $e;
            }
        }
    });
    
    // Calcul automatique des montants avant sauvegarde
    static::saving(function ($facture) {
        if (
            $facture->isDirty(['montant_ht', 'taux_tva']) ||
            $facture->montant_tva == 0 ||
            $facture->montant_ttc == 0
        ) {
            $facture->calculerMontants();
        }
    });
}
```

## ‚öñÔ∏è Contraintes Fiscales et Unicit√©

### Contrainte Base de Donn√©es

```sql
-- Migration : contrainte d'unicit√© sur numero_facture
ALTER TABLE factures 
ADD CONSTRAINT uk_factures_numero_facture 
UNIQUE (numero_facture);

-- Index pour optimiser les recherches
CREATE INDEX idx_factures_numero_pattern 
ON factures (numero_facture, created_at);

-- Index pour requ√™tes par ann√©e
CREATE INDEX idx_factures_annee 
ON factures ((SUBSTRING(numero_facture, 6, 4)), created_at);
```

### Validations Laravel

```php
// Dans FactureController.php
public function store(Request $request)
{
    $validated = $request->validate([
        // ... autres champs ...
        'numero_facture' => [
            'nullable',                    // Optionnel (auto-g√©n√©r√© si absent)
            'string',
            'max:255',
            'unique:factures,numero_facture', // Unicit√© absolue
            'regex:/^FACT-\d{4}-\d{4}$/'   // Format strict
        ],
    ], [
        'numero_facture.unique' => 'Ce num√©ro de facture existe d√©j√†',
        'numero_facture.regex' => 'Format invalide. Attendu : FACT-YYYY-NNNN'
    ]);
    
    // Si num√©ro non fourni, g√©n√©ration automatique
    if (empty($validated['numero_facture'])) {
        $validated['numero_facture'] = Facture::genererNumeroFactureRobuste();
    }
    
    // ... suite de la cr√©ation ...
}
```

### Obligations L√©gales Fran√ßaises

```php
/**
 * Service de validation fiscale des num√©ros de facture
 */
class ValidationFiscaleService
{
    /**
     * V√©rifier la conformit√© fiscale d'un num√©ro de facture
     * Selon l'article 242 nonies A du CGI
     */
    public function verifierConformiteFiscale(string $numeroFacture): array
    {
        $violations = [];
        
        // 1. Format obligatoire : num√©rotation chronologique
        if (!preg_match('/^FACT-\d{4}-\d{4}$/', $numeroFacture)) {
            $violations[] = "Format non conforme au standard chronologique";
        }
        
        // 2. Unicit√© absolue
        $doublonExiste = Facture::where('numero_facture', $numeroFacture)->count() > 1;
        if ($doublonExiste) {
            $violations[] = "Num√©ro en doublon (violation unicit√© fiscale)";
        }
        
        // 3. Coh√©rence chronologique
        $violationChronologie = $this->verifierChronologie($numeroFacture);
        if ($violationChronologie) {
            $violations[] = $violationChronologie;
        }
        
        // 4. Continuit√© de la num√©rotation
        $trouDansNumerotation = $this->detecterTrouNumerotation($numeroFacture);
        if ($trouDansNumerotation) {
            $violations[] = $trouDansNumerotation;
        }
        
        return [
            'conforme' => empty($violations),
            'violations' => $violations,
            'numero_verifie' => $numeroFacture,
            'date_verification' => now()->format('Y-m-d H:i:s')
        ];
    }
    
    /**
     * V√©rifier que la num√©rotation respecte l'ordre chronologique
     */
    private function verifierChronologie(string $numeroFacture): ?string
    {
        // Extraction ann√©e et s√©quence
        if (!preg_match('/^FACT-(\d{4})-(\d{4})$/', $numeroFacture, $matches)) {
            return null;
        }
        
        $annee = (int) $matches[1];
        $sequence = (int) $matches[2];
        
        // Recherche de factures post√©rieures avec num√©ro inf√©rieur
        $violationsChronologie = Facture::whereRaw("numero_facture LIKE 'FACT-{$annee}-%'")
                                       ->whereRaw("CAST(SUBSTRING(numero_facture, -4) AS UNSIGNED) < ?", [$sequence])
                                       ->where('created_at', '>', now())
                                       ->count();
        
        if ($violationsChronologie > 0) {
            return "Violation chronologie : num√©ro {$numeroFacture} cr√©√© apr√®s des num√©ros sup√©rieurs";
        }
        
        return null;
    }
    
    /**
     * D√©tecter les trous dans la num√©rotation s√©quentielle
     */
    private function detecterTrouNumerotation(string $numeroFacture): ?string
    {
        if (!preg_match('/^FACT-(\d{4})-(\d{4})$/', $numeroFacture, $matches)) {
            return null;
        }
        
        $annee = (int) $matches[1];
        
        // R√©cup√©rer tous les num√©ros de l'ann√©e
        $numerosExistants = Facture::where('numero_facture', 'LIKE', "FACT-{$annee}-%")
                                  ->pluck('numero_facture')
                                  ->map(function($numero) {
                                      return (int) substr($numero, -4);
                                  })
                                  ->sort()
                                  ->values()
                                  ->toArray();
        
        // V√©rifier la continuit√©
        $trous = [];
        for ($i = 1; $i < count($numerosExistants); $i++) {
            $ecart = $numerosExistants[$i] - $numerosExistants[$i-1];
            if ($ecart > 1) {
                for ($j = $numerosExistants[$i-1] + 1; $j < $numerosExistants[$i]; $j++) {
                    $trous[] = sprintf('FACT-%d-%04d', $annee, $j);
                }
            }
        }
        
        if (!empty($trous)) {
            return "Trous d√©tect√©s dans la num√©rotation : " . implode(', ', array_slice($trous, 0, 5)) . 
                   (count($trous) > 5 ? " (+" . (count($trous) - 5) . " autres)" : "");
        }
        
        return null;
    }
}
```

## üîÑ Migration des Formats Existants

### Commande de Migration

```php
// Console/Commands/MigrateFactureNumbers.php
class MigrateFactureNumbers extends Command
{
    protected $signature = 'factures:migrate-numbers 
                            {--dry-run : Afficher les changements sans les appliquer}
                            {--force : Forcer la migration m√™me en cas de conflits}';
    
    protected $description = 'Migrer les num√©ros de factures vers le format FACT-YYYY-NNNN';

    public function handle()
    {
        $dryRun = $this->option('dry-run');
        $force = $this->option('force');
        
        $this->info("üîÑ D√©but de la migration des num√©ros de factures");
        $this->info("Mode : " . ($dryRun ? "DRY-RUN (simulation)" : "PRODUCTION"));
        
        // =======================================
        // √âTAPE 1 : ANALYSE DES FORMATS EXISTANTS
        // =======================================
        
        $facturesAMigrer = Facture::whereNotNull('numero_facture')
                                 ->where('numero_facture', 'NOT LIKE', 'FACT-%')
                                 ->orderBy('created_at')
                                 ->get();
        
        $this->info("üìä Factures √† migrer : {$facturesAMigrer->count()}");
        
        if ($facturesAMigrer->isEmpty()) {
            $this->info("‚úÖ Aucune facture √† migrer. Tous les num√©ros sont d√©j√† au bon format.");
            return;
        }
        
        // =======================================
        // √âTAPE 2 : GROUPEMENT PAR ANN√âE
        // =======================================
        
        $facturesParAnnee = $facturesAMigrer->groupBy(function($facture) {
            return $facture->created_at->year;
        });
        
        $this->table(
            ['Ann√©e', 'Nombre de factures', 'Premiers formats d√©tect√©s'],
            $facturesParAnnee->map(function($factures, $annee) {
                $formatsEchantillon = $factures->take(3)->pluck('numero_facture')->implode(', ');
                return [$annee, $factures->count(), $formatsEchantillon];
            })->toArray()
        );
        
        // =======================================
        // √âTAPE 3 : MIGRATION PAR ANN√âE
        // =======================================
        
        $totalMigrees = 0;
        $erreurs = [];
        
        foreach ($facturesParAnnee as $annee => $factures) {
            $this->info("\nüóìÔ∏è Migration ann√©e {$annee} ({$factures->count()} factures)");
            
            $sequence = 1;
            
            foreach ($factures as $facture) {
                $ancienNumero = $facture->numero_facture;
                $nouveauNumero = sprintf('FACT-%d-%04d', $annee, $sequence);
                
                // V√©rification de conflit
                $conflit = Facture::where('numero_facture', $nouveauNumero)
                                 ->where('id', '!=', $facture->id)
                                 ->exists();
                
                if ($conflit && !$force) {
                    $erreurs[] = "Conflit pour {$nouveauNumero} (facture #{$facture->id})";
                    $this->error("  ‚ùå Conflit : {$ancienNumero} ‚Üí {$nouveauNumero}");
                    continue;
                }
                
                if (!$dryRun) {
                    $facture->numero_facture = $nouveauNumero;
                    $facture->save();
                    
                    // Historique de la migration
                    $facture->enregistrerHistorique(
                        'migration_numero',
                        "Migration du num√©ro de facture",
                        "Num√©ro migr√© de '{$ancienNumero}' vers '{$nouveauNumero}'",
                        ['numero_facture' => $ancienNumero],
                        ['numero_facture' => $nouveauNumero],
                        [
                            'migration_automatique' => true,
                            'annee_migration' => $annee,
                            'sequence_migration' => $sequence,
                            'commande' => 'factures:migrate-numbers'
                        ]
                    );
                }
                
                $this->line("  ‚úÖ {$ancienNumero} ‚Üí {$nouveauNumero}");
                $totalMigrees++;
                $sequence++;
            }
        }
        
        // =======================================
        // R√âSUM√â DE LA MIGRATION
        // =======================================
        
        $this->info("\nüìã R√©sum√© de la migration :");
        $this->info("   ‚úÖ Factures migr√©es : {$totalMigrees}");
        $this->info("   ‚ùå Erreurs rencontr√©es : " . count($erreurs));
        
        if (!empty($erreurs)) {
            $this->error("\nüö® Erreurs d√©taill√©es :");
            foreach ($erreurs as $erreur) {
                $this->error("   ‚Ä¢ {$erreur}");
            }
        }
        
        if ($dryRun) {
            $this->warn("\nüîç Mode DRY-RUN : Aucune modification appliqu√©e");
            $this->info("Relancez sans --dry-run pour appliquer les changements");
        } else {
            $this->info("\nüéâ Migration termin√©e avec succ√®s !");
        }
    }
}
```

### Script de Validation Post-Migration

```php
// Console/Commands/ValidateFactureNumbers.php
class ValidateFactureNumbers extends Command
{
    protected $signature = 'factures:validate-numbers {--annee=}';
    protected $description = 'Valider la conformit√© fiscale des num√©ros de factures';

    public function handle()
    {
        $anneeFiltre = $this->option('annee');
        
        $this->info("üîç Validation des num√©ros de factures");
        if ($anneeFiltre) {
            $this->info("   Ann√©e s√©lectionn√©e : {$anneeFiltre}");
        }
        
        $validationService = new ValidationFiscaleService();
        
        // R√©cup√©ration des factures √† valider
        $query = Facture::whereNotNull('numero_facture');
        if ($anneeFiltre) {
            $query->where('numero_facture', 'LIKE', "FACT-{$anneeFiltre}-%");
        }
        
        $factures = $query->orderBy('numero_facture')->get();
        
        $this->info("üìä {$factures->count()} factures √† valider\n");
        
        $conformes = 0;
        $nonConformes = 0;
        $violations = [];
        
        foreach ($factures as $facture) {
            $resultat = $validationService->verifierConformiteFiscale($facture->numero_facture);
            
            if ($resultat['conforme']) {
                $conformes++;
                $this->line("‚úÖ {$facture->numero_facture}");
            } else {
                $nonConformes++;
                $this->error("‚ùå {$facture->numero_facture}");
                foreach ($resultat['violations'] as $violation) {
                    $this->error("   ‚Üí {$violation}");
                    $violations[] = "{$facture->numero_facture}: {$violation}";
                }
            }
        }
        
        // R√©sum√© final
        $this->info("\nüìã R√©sum√© de la validation :");
        $this->info("   ‚úÖ Factures conformes : {$conformes}");
        $this->error("   ‚ùå Factures non conformes : {$nonConformes}");
        
        $tauxConformite = $factures->count() > 0 ? 
            round(($conformes / $factures->count()) * 100, 2) : 100;
        
        $this->info("   üìä Taux de conformit√© : {$tauxConformite}%");
        
        if ($nonConformes === 0) {
            $this->info("\nüéâ Toutes les factures sont conformes aux exigences fiscales !");
        } else {
            $this->warn("\n‚ö†Ô∏è Des non-conformit√©s ont √©t√© d√©tect√©es. Veuillez corriger avant tout contr√¥le fiscal.");
        }
    }
}
```

## üìã R√©sum√© de l'Auto-g√©n√©ration

### Caract√©ristiques Principales

1. **üî¢ Format Fiscal Standard** : `FACT-YYYY-NNNN` conforme au CGI
2. **‚ö° G√©n√©ration Atomique** : Transaction DB avec verrouillage
3. **üîÑ Reset Annuel** : Red√©marrage √† 0001 chaque ann√©e
4. **‚öñÔ∏è Conformit√© L√©gale** : Respect chronologie et unicit√©
5. **üõ†Ô∏è Migration Assist√©e** : Outils de conversion des anciens formats
6. **‚úÖ Validation Continue** : Contr√¥les de conformit√© automatis√©s

### Avantages vs Num√©rotation Devis

- **Conformit√© fiscale** obligatoire vs optionnelle
- **S√©quentialit√© garantie** vs bas√©e sur ID
- **Reset annuel** pour comptabilit√© vs continu
- **Format √©tendu** pour tra√ßabilit√© vs compact
- **Outils de validation** int√©gr√©s vs basiques

Cette architecture garantit une num√©rotation fiscalement conforme et juridiquement s√ªre pour toutes les factures √©mises. 