# Module 2.2 : Services M√©tier et Cache - EmailTemplate

## üìã Vue d'ensemble

Ce module documente l'architecture des services m√©tier sp√©cialis√©s pour le syst√®me EmailTemplate, incluant la logique m√©tier centralis√©e, le cache Redis intelligent, la validation approfondie et les optimisations de performance. Ces services √©tendent les fonctionnalit√©s de base du contr√¥leur pour offrir une architecture d'entreprise robuste.

## üèóÔ∏è Architecture Services EmailTemplate

### Services Sp√©cialis√©s

| **Service** | **Responsabilit√©** | **M√©thodes Principales** | **Cache** |
|-------------|-------------------|------------------------|-----------|
| `EmailTemplateService` | Logique m√©tier principale | `getTemplateForCategory()`, `processTemplateWithData()` | ‚úÖ Redis |
| `TemplateCacheService` | Gestion cache intelligent | `getDefaultTemplate()`, `invalidateCategory()` | ‚úÖ Redis |
| `TemplateValidationService` | Validation avanc√©e | `validateContent()`, `checkVariables()` | ‚ùå Non |
| `TemplateProcessingService` | Traitement optimis√© | `processWithFallback()`, `batchProcess()` | ‚úÖ Local |

### Diagramme Architecture Services

```mermaid
graph TB
    subgraph "üéÆ Controllers"
        ETC[EmailTemplateController]
        DC[DevisController]
        FC[FactureController]
    end

    subgraph "‚öôÔ∏è Services Layer"
        ETS[EmailTemplateService]
        TCS[TemplateCacheService]
        TVS[TemplateValidationService]
        TPS[TemplateProcessingService]
    end

    subgraph "üíæ Cache Layer"
        REDIS[(Redis Cache)]
        LOCAL[Local Cache]
        DB[(Database)]
    end

    subgraph "üìä Monitoring"
        METRICS[Cache Metrics]
        LOGS[Performance Logs]
    end

    ETC --> ETS
    DC --> ETS
    FC --> ETS
    
    ETS --> TCS
    ETS --> TVS
    ETS --> TPS
    
    TCS --> REDIS
    TPS --> LOCAL
    ETS --> DB
    
    TCS --> METRICS
    TPS --> LOGS
```

## üöÄ EmailTemplateService - Service Principal

### Architecture et Responsabilit√©s

Le service principal centralise toute la logique m√©tier des templates d'emails.

```php
<?php

namespace App\Services;

use App\Models\EmailTemplate;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;
use Carbon\Carbon;

class EmailTemplateService
{
    private TemplateCacheService $cacheService;
    private TemplateValidationService $validationService;
    private TemplateProcessingService $processingService;

    public function __construct(
        TemplateCacheService $cacheService,
        TemplateValidationService $validationService,
        TemplateProcessingService $processingService
    ) {
        $this->cacheService = $cacheService;
        $this->validationService = $validationService;
        $this->processingService = $processingService;
    }

    /**
     * R√©cup√©rer le template optimal pour une cat√©gorie
     */
    public function getTemplateForCategory(
        string $category, 
        ?string $subCategory = null,
        bool $preferDefault = true
    ): ?EmailTemplate {
        // 1. Tentative cache pour template par d√©faut
        if ($preferDefault) {
            $template = $this->cacheService->getDefaultTemplate($category);
            if ($template) {
                return $template;
            }
        }

        // 2. Recherche avec sous-cat√©gorie sp√©cifique
        if ($subCategory) {
            $template = EmailTemplate::active()
                ->byCategory($category)
                ->where('sub_category', $subCategory)
                ->orderBy('is_default', 'desc')
                ->first();
            
            if ($template) {
                return $template;
            }
        }

        // 3. Fallback : premier template actif de la cat√©gorie
        $template = EmailTemplate::active()
            ->byCategory($category)
            ->orderBy('is_default', 'desc')
            ->orderBy('created_at')
            ->first();

        // Log si aucun template par d√©faut trouv√©
        if ($template && !$template->is_default) {
            Log::warning('Template par d√©faut manquant', [
                'category' => $category,
                'sub_category' => $subCategory,
                'fallback_template_id' => $template->id,
            ]);
        }

        return $template;
    }

    /**
     * Traiter un template avec donn√©es et validation
     */
    public function processTemplateWithData(
        EmailTemplate $template, 
        array $data, 
        bool $validateVariables = true
    ): array {
        // 1. Validation des variables si demand√©e
        if ($validateVariables) {
            $validation = $this->validationService->validateVariables($template, $data);
            if (!$validation['valid']) {
                Log::warning('Variables template invalides', [
                    'template_id' => $template->id,
                    'validation' => $validation,
                ]);
            }
        }

        // 2. Traitement avec service sp√©cialis√©
        $processed = $this->processingService->processWithFallback($template, $data);

        // 3. M√©triques d'utilisation
        $this->recordUsageMetrics($template, $data);

        return $processed;
    }

    /**
     * Cr√©er un nouveau template avec validation compl√®te
     */
    public function createTemplate(array $data): EmailTemplate
    {
        // 1. Validation du contenu
        $validation = $this->validationService->validateContent(
            $data['subject'], 
            $data['body'],
            $data['variables'] ?? []
        );

        if (!$validation['valid']) {
            throw new \InvalidArgumentException(
                'Template invalide : ' . implode(', ', $validation['errors'])
            );
        }

        // 2. Cr√©ation avec gestion des d√©fauts
        DB::beginTransaction();
        
        try {
            $template = EmailTemplate::create($data);

            // 3. Gestion template par d√©faut
            if ($template->is_default) {
                $this->setAsDefaultTemplate($template);
            }

            // 4. Invalidation cache
            $this->cacheService->invalidateCategory($template->category);

            DB::commit();

            Log::info('Template cr√©√© avec succ√®s', [
                'template_id' => $template->id,
                'name' => $template->name,
                'category' => $template->category,
            ]);

            return $template;

        } catch (\Exception $e) {
            DB::rollback();
            throw $e;
        }
    }

    /**
     * D√©finir un template comme d√©faut pour sa cat√©gorie
     */
    public function setAsDefaultTemplate(EmailTemplate $template): void
    {
        // D√©sactiver les autres templates par d√©faut de la m√™me cat√©gorie
        EmailTemplate::where('category', $template->category)
                    ->where('is_default', true)
                    ->where('id', '!=', $template->id)
                    ->update(['is_default' => false]);

        // Activer le nouveau template par d√©faut
        $template->update(['is_default' => true]);

        // Invalidation cache imm√©diate
        $this->cacheService->invalidateCategory($template->category);

        Log::info('Template d√©fini comme d√©faut', [
            'template_id' => $template->id,
            'category' => $template->category,
        ]);
    }

    /**
     * Duplicer un template avec options avanc√©es
     */
    public function duplicateTemplate(
        EmailTemplate $template, 
        array $options = []
    ): EmailTemplate {
        $newData = $template->toArray();
        unset($newData['id'], $newData['created_at'], $newData['updated_at']);

        // Options de duplication
        $newData['name'] = $options['name'] ?? $template->name . ' (Copie)';
        $newData['is_default'] = false; // Jamais par d√©faut lors de duplication
        $newData['is_active'] = $options['active'] ?? true;
        
        // Modification de cat√©gorie optionnelle
        if (!empty($options['category'])) {
            $newData['category'] = $options['category'];
        }
        if (!empty($options['sub_category'])) {
            $newData['sub_category'] = $options['sub_category'];
        }

        return $this->createTemplate($newData);
    }

    /**
     * Statistiques d'utilisation par p√©riode
     */
    public function getUsageStatistics(string $period = '30d'): array
    {
        $cacheKey = "template_stats_{$period}";
        
        return Cache::remember($cacheKey, 3600, function () use ($period) {
            $days = (int) str_replace('d', '', $period);
            $since = Carbon::now()->subDays($days);

            return [
                'period' => $period,
                'total_templates' => EmailTemplate::count(),
                'active_templates' => EmailTemplate::where('is_active', true)->count(),
                'categories_stats' => EmailTemplate::selectRaw('
                    category, 
                    COUNT(*) as total, 
                    SUM(CASE WHEN is_active = 1 THEN 1 ELSE 0 END) as active,
                    SUM(CASE WHEN is_default = 1 THEN 1 ELSE 0 END) as defaults
                ')
                ->groupBy('category')
                ->get()
                ->keyBy('category'),
                'recent_activity' => [
                    'created' => EmailTemplate::where('created_at', '>=', $since)->count(),
                    'updated' => EmailTemplate::where('updated_at', '>=', $since)
                                              ->where('updated_at', '!=', 'created_at')
                                              ->count(),
                ],
                'generated_at' => now()->toISOString(),
            ];
        });
    }

    /**
     * Enregistrer les m√©triques d'utilisation
     */
    private function recordUsageMetrics(EmailTemplate $template, array $data): void
    {
        $metricsKey = "template_usage_{$template->id}_" . date('Y-m-d');
        
        Cache::increment($metricsKey, 1);
        Cache::expire($metricsKey, 86400 * 30); // 30 jours

        // Log d√©taill√© pour analyse
        Log::info('Template utilis√©', [
            'template_id' => $template->id,
            'category' => $template->category,
            'variables_provided' => count($data),
            'date' => date('Y-m-d H:i:s'),
        ]);
    }
}
```

## üóÑÔ∏è TemplateCacheService - Cache Intelligent

### Strat√©gie de Cache Multi-Niveaux

Service d√©di√© √† la gestion optimis√©e du cache Redis pour les templates.

```php
<?php

namespace App\Services;

use App\Models\EmailTemplate;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Redis;
use Carbon\Carbon;

class TemplateCacheService
{
    // Configuration cache
    private const DEFAULT_TTL = 3600; // 1 heure
    private const ACTIVE_TTL = 1800;  // 30 minutes
    private const STATS_TTL = 300;    // 5 minutes
    
    private const CACHE_PREFIX = 'email_template_';
    private const REDIS_CONNECTION = 'cache';

    /**
     * R√©cup√©rer template par d√©faut avec cache intelligent
     */
    public function getDefaultTemplate(string $category): ?EmailTemplate
    {
        $cacheKey = self::CACHE_PREFIX . "default_{$category}";
        
        return Cache::remember($cacheKey, self::DEFAULT_TTL, function () use ($category) {
            return EmailTemplate::defaultForCategory($category)
                                ->active()
                                ->with([])  // Pas de relations pour optimiser
                                ->first();
        });
    }

    /**
     * Cache des templates actifs par cat√©gorie
     */
    public function getActiveTemplates(string $category): \Illuminate\Support\Collection
    {
        $cacheKey = self::CACHE_PREFIX . "active_{$category}";
        
        return Cache::remember($cacheKey, self::ACTIVE_TTL, function () use ($category) {
            return EmailTemplate::active()
                                ->byCategory($category)
                                ->select(['id', 'name', 'subject', 'is_default', 'sub_category'])
                                ->orderBy('is_default', 'desc')
                                ->orderBy('name')
                                ->get();
        });
    }

    /**
     * Cache template complet avec contenu
     */
    public function getFullTemplate(int $templateId): ?EmailTemplate
    {
        $cacheKey = self::CACHE_PREFIX . "full_{$templateId}";
        
        return Cache::remember($cacheKey, self::DEFAULT_TTL, function () use ($templateId) {
            return EmailTemplate::find($templateId);
        });
    }

    /**
     * Invalidation intelligente par cat√©gorie
     */
    public function invalidateCategory(string $category): void
    {
        $patterns = [
            self::CACHE_PREFIX . "default_{$category}",
            self::CACHE_PREFIX . "active_{$category}",
        ];

        foreach ($patterns as $pattern) {
            Cache::forget($pattern);
        }

        // Invalidation templates individuels de la cat√©gorie
        $templateIds = EmailTemplate::byCategory($category)->pluck('id');
        foreach ($templateIds as $id) {
            Cache::forget(self::CACHE_PREFIX . "full_{$id}");
        }

        Log::info('Cache category invalidated', [
            'category' => $category,
            'patterns_cleared' => count($patterns),
            'templates_cleared' => $templateIds->count(),
        ]);
    }

    /**
     * Invalidation template sp√©cifique
     */
    public function invalidateTemplate(EmailTemplate $template): void
    {
        $patterns = [
            self::CACHE_PREFIX . "full_{$template->id}",
            self::CACHE_PREFIX . "default_{$template->category}",
            self::CACHE_PREFIX . "active_{$template->category}",
        ];

        foreach ($patterns as $pattern) {
            Cache::forget($pattern);
        }

        Log::info('Template cache invalidated', [
            'template_id' => $template->id,
            'category' => $template->category,
        ]);
    }

    /**
     * Pr√©chargement des templates fr√©quents
     */
    public function preloadFrequentTemplates(): array
    {
        $preloaded = [];
        $categories = array_keys(EmailTemplate::CATEGORIES);

        foreach ($categories as $category) {
            // Pr√©charger template par d√©faut
            $default = $this->getDefaultTemplate($category);
            if ($default) {
                $preloaded[$category] = $default;
            }

            // Pr√©charger templates actifs
            $active = $this->getActiveTemplates($category);
            $preloaded["{$category}_active"] = $active->count();
        }

        Log::info('Templates preloaded', [
            'categories' => count($categories),
            'defaults_loaded' => count(array_filter($preloaded, fn($v) => $v instanceof EmailTemplate)),
        ]);

        return $preloaded;
    }

    /**
     * Nettoyage cache expir√©
     */
    public function cleanExpiredCache(): int
    {
        $redis = Redis::connection(self::REDIS_CONNECTION);
        $pattern = config('cache.prefix') . ':' . self::CACHE_PREFIX . '*';
        
        $keys = $redis->keys($pattern);
        $cleaned = 0;

        foreach ($keys as $key) {
            $ttl = $redis->ttl($key);
            if ($ttl === -1 || $ttl === -2) { // Cl√©s sans TTL ou expir√©es
                $redis->del($key);
                $cleaned++;
            }
        }

        Log::info('Cache cleaned', [
            'keys_checked' => count($keys),
            'keys_cleaned' => $cleaned,
        ]);

        return $cleaned;
    }

    /**
     * Statistiques cache en temps r√©el
     */
    public function getCacheStatistics(): array
    {
        $cacheKey = self::CACHE_PREFIX . 'stats';
        
        return Cache::remember($cacheKey, self::STATS_TTL, function () {
            $redis = Redis::connection(self::REDIS_CONNECTION);
            $pattern = config('cache.prefix') . ':' . self::CACHE_PREFIX . '*';
            $keys = $redis->keys($pattern);

            $stats = [
                'total_keys' => count($keys),
                'by_type' => [
                    'default' => 0,
                    'active' => 0,
                    'full' => 0,
                    'other' => 0,
                ],
                'memory_usage' => 0,
                'avg_ttl' => 0,
            ];

            $totalTtl = 0;
            foreach ($keys as $key) {
                $memory = $redis->memory('usage', $key) ?? 0;
                $stats['memory_usage'] += $memory;
                
                $ttl = $redis->ttl($key);
                if ($ttl > 0) {
                    $totalTtl += $ttl;
                }

                // Cat√©gorisation par type
                if (strpos($key, 'default_') !== false) {
                    $stats['by_type']['default']++;
                } elseif (strpos($key, 'active_') !== false) {
                    $stats['by_type']['active']++;
                } elseif (strpos($key, 'full_') !== false) {
                    $stats['by_type']['full']++;
                } else {
                    $stats['by_type']['other']++;
                }
            }

            $stats['avg_ttl'] = count($keys) > 0 ? round($totalTtl / count($keys)) : 0;
            $stats['memory_usage_formatted'] = $this->formatBytes($stats['memory_usage']);

            return $stats;
        });
    }

    /**
     * R√©chauffage cache proactif
     */
    public function warmupCache(): array
    {
        $warmed = [];
        $categories = array_keys(EmailTemplate::CATEGORIES);

        foreach ($categories as $category) {
            // R√©chauffer templates par d√©faut
            $default = $this->getDefaultTemplate($category);
            $warmed['defaults'][$category] = $default ? true : false;

            // R√©chauffer templates actifs
            $active = $this->getActiveTemplates($category);
            $warmed['active'][$category] = $active->count();
        }

        // Templates les plus utilis√©s (top 10)
        $topTemplates = EmailTemplate::active()
                                   ->withCount(['usageMetrics' => function ($query) {
                                       $query->where('created_at', '>=', Carbon::now()->subDays(7));
                                   }])
                                   ->orderBy('usage_metrics_count', 'desc')
                                   ->take(10)
                                   ->get();

        foreach ($topTemplates as $template) {
            $this->getFullTemplate($template->id);
            $warmed['top_templates'][$template->id] = $template->name;
        }

        Log::info('Cache warmed up', $warmed);

        return $warmed;
    }

    /**
     * Formatage taille m√©moire
     */
    private function formatBytes(int $bytes): string
    {
        $units = ['B', 'KB', 'MB', 'GB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);

        $bytes /= pow(1024, $pow);

        return round($bytes, 2) . ' ' . $units[$pow];
    }
}
```

## ‚úÖ TemplateValidationService - Validation Approfondie

### Validation Avanc√©e des Templates

Service sp√©cialis√© dans la validation m√©tier et technique des templates.

```php
<?php

namespace App\Services;

use App\Models\EmailTemplate;

class TemplateValidationService
{
    /**
     * Validation compl√®te du contenu d'un template
     */
    public function validateContent(
        string $subject, 
        string $body, 
        array $declaredVariables = []
    ): array {
        $errors = [];
        $warnings = [];

        // 1. Validation de base
        if (empty(trim($subject))) {
            $errors[] = 'Le sujet ne peut pas √™tre vide';
        }

        if (empty(trim($body))) {
            $errors[] = 'Le corps ne peut pas √™tre vide';
        }

        if (strlen($subject) > 255) {
            $errors[] = 'Le sujet ne peut pas d√©passer 255 caract√®res';
        }

        // 2. Validation des variables
        $variableAnalysis = $this->analyzeVariables($subject . ' ' . $body, $declaredVariables);

        // Variables utilis√©es mais non d√©clar√©es
        if (!empty($variableAnalysis['undeclared'])) {
            $warnings[] = 'Variables utilis√©es mais non d√©clar√©es : ' . 
                         implode(', ', $variableAnalysis['undeclared']);
        }

        // Variables d√©clar√©es mais non utilis√©es
        if (!empty($variableAnalysis['unused'])) {
            $warnings[] = 'Variables d√©clar√©es mais non utilis√©es : ' . 
                         implode(', ', $variableAnalysis['unused']);
        }

        // Variables avec syntaxe invalide
        foreach ($variableAnalysis['used'] as $variable) {
            if (!preg_match('/^[a-zA-Z_][a-zA-Z0-9_]*$/', $variable)) {
                $errors[] = "Variable avec syntaxe invalide : '{$variable}'";
            }
        }

        // 3. Validation HTML/s√©curit√©
        $securityCheck = $this->validateSecurity($body);
        if (!$securityCheck['safe']) {
            $errors = array_merge($errors, $securityCheck['issues']);
        }

        // 4. Validation liens et images
        $linkValidation = $this->validateLinks($body);
        if (!empty($linkValidation['broken_patterns'])) {
            $warnings = array_merge($warnings, $linkValidation['broken_patterns']);
        }

        return [
            'valid' => empty($errors),
            'errors' => $errors,
            'warnings' => $warnings,
            'variable_analysis' => $variableAnalysis,
            'security_check' => $securityCheck,
            'link_validation' => $linkValidation,
        ];
    }

    /**
     * Validation des variables par rapport aux donn√©es fournies
     */
    public function validateVariables(EmailTemplate $template, array $data): array
    {
        $content = $template->subject . ' ' . $template->body;
        $analysis = $this->analyzeVariables($content, $template->variables ?? []);
        
        $missingData = array_diff($analysis['used'], array_keys($data));
        $unusedData = array_diff(array_keys($data), $analysis['used']);

        return [
            'valid' => empty($missingData),
            'missing_data' => $missingData,
            'unused_data' => $unusedData,
            'variable_analysis' => $analysis,
        ];
    }

    /**
     * Analyse des variables dans le contenu
     */
    private function analyzeVariables(string $content, array $declaredVariables): array
    {
        // D√©tecter variables utilis√©es (formats {{var}} et {{{var}}})
        preg_match_all('/\{\{?\{?([^}]+)\}?\}?\}/', $content, $matches);
        $usedVariables = array_unique(array_map('trim', $matches[1]));

        return [
            'used' => $usedVariables,
            'declared' => $declaredVariables,
            'undeclared' => array_diff($usedVariables, $declaredVariables),
            'unused' => array_diff($declaredVariables, $usedVariables),
            'total_used' => count($usedVariables),
            'total_declared' => count($declaredVariables),
        ];
    }

    /**
     * Validation s√©curit√© (XSS, scripts)
     */
    private function validateSecurity(string $content): array
    {
        $issues = [];
        $safe = true;

        // D√©tecter scripts potentiellement dangereux
        $dangerousPatterns = [
            '/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/mi',
            '/javascript:/i',
            '/on\w+\s*=/i', // √©v√©nements onclick, onload, etc.
            '/<iframe\b/i',
            '/<object\b/i',
            '/<embed\b/i',
        ];

        foreach ($dangerousPatterns as $pattern) {
            if (preg_match($pattern, $content)) {
                $issues[] = 'Contenu potentiellement dangereux d√©tect√©';
                $safe = false;
                break;
            }
        }

        // V√©rifier balises HTML autoris√©es
        $allowedTags = ['p', 'br', 'strong', 'em', 'u', 'a', 'img', 'h1', 'h2', 'h3', 'h4', 'ul', 'ol', 'li'];
        $strippedContent = strip_tags($content, '<' . implode('><', $allowedTags) . '>');
        
        if ($strippedContent !== $content) {
            $issues[] = 'Balises HTML non autoris√©es d√©tect√©es';
            $safe = false;
        }

        return [
            'safe' => $safe,
            'issues' => $issues,
            'checked_patterns' => count($dangerousPatterns),
        ];
    }

    /**
     * Validation des liens
     */
    private function validateLinks(string $content): array
    {
        $brokenPatterns = [];

        // Liens avec domaines suspects
        if (preg_match_all('/https?:\/\/([^\s<>"\']+)/i', $content, $matches)) {
            foreach ($matches[1] as $domain) {
                if (strpos($domain, 'localhost') !== false && !app()->environment('local')) {
                    $brokenPatterns[] = "Lien localhost d√©tect√© en production : {$domain}";
                }
            }
        }

        // Variables dans les liens (peuvent √™tre probl√©matiques)
        if (preg_match_all('/href=["\']\{\{[^}]+\}\}[^"\']*["\']/i', $content, $matches)) {
            foreach ($matches[0] as $match) {
                $brokenPatterns[] = "Lien avec variable non trait√©e : {$match}";
            }
        }

        return [
            'broken_patterns' => $brokenPatterns,
            'total_links' => preg_match_all('/https?:\/\/[^\s<>"\']+/i', $content),
        ];
    }
}
```

## ‚ö° TemplateProcessingService - Traitement Optimis√©

### Service de Traitement avec Fallbacks

```php
<?php

namespace App\Services;

use App\Models\EmailTemplate;
use Illuminate\Support\Facades\Log;

class TemplateProcessingService
{
    /**
     * Traitement avec fallback automatique
     */
    public function processWithFallback(EmailTemplate $template, array $data): array
    {
        try {
            // Traitement principal
            $result = $this->processTemplate($template, $data);
            
            // Validation du r√©sultat
            if ($this->isValidResult($result)) {
                return $result;
            }

            // Fallback si r√©sultat invalide
            Log::warning('R√©sultat traitement invalide, utilisation fallback', [
                'template_id' => $template->id,
                'data_keys' => array_keys($data),
            ]);

            return $this->processWithFallbackData($template, $data);

        } catch (\Exception $e) {
            Log::error('Erreur traitement template', [
                'template_id' => $template->id,
                'error' => $e->getMessage(),
            ]);

            return $this->processWithFallbackData($template, $data);
        }
    }

    /**
     * Traitement batch de plusieurs templates
     */
    public function batchProcess(array $templates, array $commonData): array
    {
        $results = [];
        $startTime = microtime(true);

        foreach ($templates as $template) {
            $templateStart = microtime(true);
            
            $results[$template->id] = [
                'template' => $template,
                'result' => $this->processWithFallback($template, $commonData),
                'processing_time' => (microtime(true) - $templateStart) * 1000,
            ];
        }

        $totalTime = (microtime(true) - $startTime) * 1000;

        Log::info('Batch processing completed', [
            'templates_count' => count($templates),
            'total_time_ms' => $totalTime,
            'avg_time_ms' => $totalTime / count($templates),
        ]);

        return $results;
    }

    /**
     * Traitement principal d'un template
     */
    private function processTemplate(EmailTemplate $template, array $data): array
    {
        $subject = $template->subject;
        $body = $template->body;

        // Traitement variables avec formats multiples
        foreach ($data as $key => $value) {
            $value = $this->sanitizeValue($value);
            
            // Format triple accolades {{{var}}}
            $subject = str_replace("{{{$key}}}", $value, $subject);
            $body = str_replace("{{{$key}}}", $value, $body);
            
            // Format double accolades {{var}}
            $subject = str_replace("{{$key}}", $value, $subject);
            $body = str_replace("{{$key}}", $value, $body);
        }

        return [
            'subject' => $subject,
            'body' => $body,
            'variables_processed' => count($data),
            'processing_timestamp' => now()->toISOString(),
        ];
    }

    /**
     * Traitement avec donn√©es de fallback
     */
    private function processWithFallbackData(EmailTemplate $template, array $originalData): array
    {
        // Donn√©es de fallback s√©curis√©es
        $fallbackData = array_merge([
            'client_nom' => '[NOM_CLIENT]',
            'entreprise_nom' => config('app.company_name', 'Votre Entreprise'),
            'devis_numero' => '[NUMERO_DEVIS]',
            'facture_numero' => '[NUMERO_FACTURE]',
            'contact_email' => config('mail.from.address', 'contact@exemple.com'),
            'date_aujourdhui' => now()->format('d/m/Y'),
        ], $originalData);

        return $this->processTemplate($template, $fallbackData);
    }

    /**
     * Validation du r√©sultat de traitement
     */
    private function isValidResult(array $result): bool
    {
        return isset($result['subject'], $result['body']) &&
               !empty(trim($result['subject'])) &&
               !empty(trim($result['body']));
    }

    /**
     * Nettoyage s√©curis√© des valeurs
     */
    private function sanitizeValue($value): string
    {
        if (is_null($value)) {
            return '';
        }

        if (is_array($value)) {
            return implode(', ', $value);
        }

        return htmlspecialchars((string) $value, ENT_QUOTES, 'UTF-8');
    }
}
```

## üîß Commandes Artisan pour Services

### Gestion des Services via CLI

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Services\EmailTemplateService;
use App\Services\TemplateCacheService;

class EmailTemplateServiceCommand extends Command
{
    protected $signature = 'email-templates:service 
                          {action : Action (cache:clear, cache:warm, cache:stats, validate:all)}
                          {--category= : Cat√©gorie sp√©cifique}';
    
    protected $description = 'Gestion des services EmailTemplate';

    public function handle(
        EmailTemplateService $templateService,
        TemplateCacheService $cacheService
    ) {
        $action = $this->argument('action');
        $category = $this->option('category');

        switch ($action) {
            case 'cache:clear':
                $this->clearCache($cacheService, $category);
                break;
                
            case 'cache:warm':
                $this->warmCache($cacheService);
                break;
                
            case 'cache:stats':
                $this->showCacheStats($cacheService);
                break;
                
            case 'validate:all':
                $this->validateAllTemplates($templateService);
                break;
                
            default:
                $this->error("Action inconnue : {$action}");
                return Command::FAILURE;
        }

        return Command::SUCCESS;
    }

    private function clearCache(TemplateCacheService $cacheService, ?string $category): void
    {
        if ($category) {
            $cacheService->invalidateCategory($category);
            $this->info("‚úÖ Cache nettoy√© pour la cat√©gorie : {$category}");
        } else {
            $cleaned = $cacheService->cleanExpiredCache();
            $this->info("‚úÖ Cache nettoy√© : {$cleaned} entr√©es supprim√©es");
        }
    }

    private function warmCache(TemplateCacheService $cacheService): void
    {
        $this->info('üîÑ R√©chauffage du cache...');
        $results = $cacheService->warmupCache();
        
        $this->table(
            ['Type', 'Cat√©gorie', 'R√©sultat'],
            collect($results)->flatMap(function ($items, $type) {
                return collect($items)->map(function ($result, $key) use ($type) {
                    return [$type, $key, is_bool($result) ? ($result ? '‚úÖ' : '‚ùå') : $result];
                });
            })->toArray()
        );
    }

    private function showCacheStats(TemplateCacheService $cacheService): void
    {
        $stats = $cacheService->getCacheStatistics();
        
        $this->info('üìä Statistiques Cache EmailTemplate');
        $this->line('');
        
        $this->table(
            ['M√©trique', 'Valeur'],
            [
                ['Total cl√©s', $stats['total_keys']],
                ['Templates par d√©faut', $stats['by_type']['default']],
                ['Templates actifs', $stats['by_type']['active']],
                ['Templates complets', $stats['by_type']['full']],
                ['Utilisation m√©moire', $stats['memory_usage_formatted']],
                ['TTL moyen', $stats['avg_ttl'] . ' secondes'],
            ]
        );
    }

    private function validateAllTemplates(EmailTemplateService $templateService): void
    {
        // Implementation validation compl√®te...
        $this->info('üîç Validation de tous les templates...');
        // TODO: Impl√©menter validation compl√®te
    }
}
```

## üìä Int√©gration et Usage

### Utilisation dans les Contr√¥leurs

```php
// Dans EmailTemplateController
class EmailTemplateController extends Controller
{
    private EmailTemplateService $templateService;

    public function __construct(EmailTemplateService $templateService)
    {
        $this->templateService = $templateService;
    }

    public function store(Request $request)
    {
        try {
            $template = $this->templateService->createTemplate($validated);
            return redirect()->route('email-templates.show', $template)
                           ->with('success', 'Template cr√©√© avec succ√®s');
        } catch (\InvalidArgumentException $e) {
            return back()->withErrors(['validation' => $e->getMessage()]);
        }
    }
}

// Dans DevisController  
class DevisController extends Controller
{
    private EmailTemplateService $templateService;

    private function envoyerEmailClientDevis(Devis $devis, ?int $templateId = null)
    {
        $template = $templateId 
            ? EmailTemplate::find($templateId)
            : $this->templateService->getTemplateForCategory('envoi_initial');

        if (!$template) {
            throw new \Exception('Aucun template disponible');
        }

        $data = [
            'client_nom' => $devis->client->nom_complet,
            'devis_numero' => $devis->numero_devis,
            // ... autres variables
        ];

        $processed = $this->templateService->processTemplateWithData($template, $data);
        
        // Utilisation dans l'email...
    }
}
```

## üìù Conclusion Module 2.2

Le **Module 2.2 Services M√©tier et Cache** apporte une **architecture d'entreprise** au syst√®me EmailTemplate avec :

### ‚úÖ Services Sp√©cialis√©s
- **EmailTemplateService** : Logique m√©tier centralis√©e et robuste
- **TemplateCacheService** : Cache Redis intelligent avec invalidation
- **TemplateValidationService** : Validation approfondie et s√©curit√©
- **TemplateProcessingService** : Traitement optimis√© avec fallbacks

### üöÄ Performance et Fiabilit√©
- **Cache multi-niveaux** Redis optimis√©
- **Invalidation intelligente** lors des modifications
- **Fallbacks automatiques** en cas d'erreur
- **M√©triques temps r√©el** pour monitoring

### üîß Outils d'Administration
- **Commandes artisan** pour gestion cache
- **Validation compl√®te** des templates
- **Statistiques d√©taill√©es** d'utilisation
- **Monitoring proactif** des performances

Cette architecture de services garantit **performance**, **fiabilit√©** et **maintenabilit√©** pour le syst√®me EmailTemplate en production. 