# Module 1.2 : MÃ©thodes MÃ©tier Templates - Logique AvancÃ©e et Traitement

## ğŸ“‹ Vue d'ensemble

Ce module documente en profondeur les **mÃ©thodes mÃ©tier** du systÃ¨me EmailTemplate, avec un focus sur les traitements avancÃ©s, la logique de gestion exclusive des templates par dÃ©faut, et les optimisations de requÃªtes. Ces mÃ©thodes constituent le cÅ“ur opÃ©rationnel du systÃ¨me de templates.

## ğŸ”§ MÃ©thode processTemplate() - Traitement AvancÃ© des Variables

### Architecture du Traitement

La mÃ©thode `processTemplate()` est le cÅ“ur du systÃ¨me de personnalisation des emails, supportant **deux formats de variables** pour une flexibilitÃ© maximale.

```php
/**
 * Traite un template en remplaÃ§ant les variables par les donnÃ©es fournies
 * Support dual : `&#123;&#123;variable&#125;&#125;` et `&#123;&#123;&#123;variable&#125;&#125;&#125;`
 * 
 * @param array $data DonnÃ©es de remplacement ['key' => 'value']
 * @return array ['subject' => string, 'body' => string]
 */
public function processTemplate(array $data = [])
{
    $subject = $this->subject;
    $body = $this->body;

    foreach ($data as $key => $value) {
            // Format triple accolades : &#123;&#123;&#123;variable&#125;&#125;&#125; (prioritÃ©)
    $subject = str_replace("&#123;&#123;&#123;$key&#125;&#125;&#125;", $value, $subject);
    $body = str_replace("&#123;&#123;&#123;$key&#125;&#125;&#125;", $value, $body);
    
    // Format double accolades : &#123;&#123;variable&#125;&#125; (standard)
    $subject = str_replace("&#123;&#123;$key&#125;&#125;", $value, $subject);
    $body = str_replace("&#123;&#123;$key&#125;&#125;", $value, $body);
    }

    return [
        'subject' => $subject,
        'body' => $body
    ];
}
```

### Formats de Variables SupportÃ©s

#### ğŸ“Œ Format Standard : `&#123;&#123;variable&#125;&#125;`
```php
// Template avec format standard
$subject = "Devis &#123;&#123;devis_numero&#125;&#125; - &#123;&#123;entreprise_nom&#125;&#125;";
$body = "Bonjour &#123;&#123;client_nom&#125;&#125;, votre devis est prÃªt.";

// RÃ©sultat attendu
// Subject: "Devis DV-25-001 - TechCorp"
// Body: "Bonjour M. Dupont, votre devis est prÃªt."
```

#### ğŸ“Œ Format AvancÃ© : `&#123;&#123;&#123;variable&#125;&#125;&#125;`
```php
// Template avec format avancÃ© (pour cas spÃ©ciaux)
$subject = "Urgent : &#123;&#123;&#123;type_urgence&#125;&#125;&#125; &#123;&#123;devis_numero&#125;&#125;";
$body = "Traitement &#123;&#123;&#123;priorite&#125;&#125;&#125; pour &#123;&#123;client_nom&#125;&#125;.";
```

### Exemples d'Utilisation Pratique

#### ğŸ“§ Envoi Initial avec Template Promotionnel
```php
$template = EmailTemplate::getDefaultForCategory('envoi_initial');

$data = [
    'client_nom' => 'M. Dubois',
    'entreprise_nom' => 'Madinia Solutions',
    'devis_numero' => 'DV-25-0042',
    'devis_montant' => '3 750,00 â‚¬',
    'devis_validite' => '15/02/2025',
    'contact_telephone' => '01 23 45 67 89',
    'contact_email' => 'contact@madinia.fr'
];

$processed = $template->processTemplate($data);

// RÃ©sultat automatique
$emailData = [
    'subject' => 'ğŸ‰ Offre spÃ©ciale - Votre devis DV-25-0042',
    'body' => "Bonjour M. Dubois,

C'est avec enthousiasme que nous vous prÃ©sentons notre devis nÂ° DV-25-0042...
Cette offre spÃ©ciale d'un montant de 3 750,00 â‚¬ est valable jusqu'au 15/02/2025..."
];
```

#### ğŸ“ Rappel avec DonnÃ©es Dynamiques
```php
$template = EmailTemplate::active()
    ->byCategory('rappel')
    ->where('sub_category', 'rappel_date_expiration')
    ->first();

$data = [
    'client_nom' => 'Mme Martin',
    'devis_numero' => 'DV-25-0043', 
    'devis_montant' => '1 250,00 â‚¬',
    'devis_validite' => '20/02/2025',
    'jours_restants' => '3 jours'
];

$processed = $template->processTemplate($data);

// Email de rappel automatiquement personnalisÃ©
// Subject: "â³ Votre devis DV-25-0043 expire bientÃ´t"
```

### Gestion des Variables Manquantes

```php
// MÃ©thode robuste avec gestion des variables manquantes
public function processTemplate(array $data = [])
{
    $subject = $this->subject;
    $body = $this->body;

    // Traitement sÃ©curisÃ© des variables
    foreach ($data as $key => $value) {
        // Validation et nettoyage de la valeur
        $cleanValue = is_null($value) ? '' : (string) $value;
        
        // Remplacement sÃ©curisÃ©
        $subject = str_replace(["&#123;&#123;&#123;$key&#125;&#125;&#125;", "&#123;&#123;$key&#125;&#125;"], $cleanValue, $subject);
        $body = str_replace(["&#123;&#123;&#123;$key&#125;&#125;&#125;", "&#123;&#123;$key&#125;&#125;"], $cleanValue, $body);
    }

    // Post-traitement : nettoyer les variables non remplacÃ©es
    $subject = preg_replace('/\{\{[^}]+\}\}/', '[Variable manquante]', $subject);
    $body = preg_replace('/\{\{[^}]+\}\}/', '[Variable manquante]', $body);

    return [
        'subject' => trim($subject),
        'body' => trim($body)
    ];
}
```

## ğŸ¯ MÃ©thode setAsDefault() - Gestion Exclusive

### Architecture de l'ExclusivitÃ©

La mÃ©thode `setAsDefault()` implÃ©mente un **systÃ¨me d'exclusivitÃ©** garantissant qu'une seule template par catÃ©gorie peut Ãªtre dÃ©finie comme par dÃ©faut.

```php
/**
 * DÃ©finit ce template comme par dÃ©faut pour sa catÃ©gorie
 * Garantit l'exclusivitÃ© : un seul template par dÃ©faut par catÃ©gorie
 * 
 * @return bool True si succÃ¨s, False si erreur
 * @throws \Exception Si erreur lors de la transaction
 */
public function setAsDefault()
{
    try {
        \DB::transaction(function () {
            // Ã‰tape 1 : Retirer le statut par dÃ©faut des autres templates
            self::where('category', $this->category)
                ->where('id', '!=', $this->id)
                ->update(['is_default' => false]);

            // Ã‰tape 2 : DÃ©finir ce template comme par dÃ©faut
            $this->update(['is_default' => true]);
            
            // Ã‰tape 3 : Log de l'opÃ©ration
            \Log::info('Template dÃ©fini comme par dÃ©faut', [
                'template_id' => $this->id,
                'template_name' => $this->name,
                'category' => $this->category,
                'user_id' => auth()->id()
            ]);
        });

        return true;
    } catch (\Exception $e) {
        \Log::error('Erreur lors de la dÃ©finition du template par dÃ©faut', [
            'template_id' => $this->id,
            'error' => $e->getMessage()
        ]);
        
        throw $e;
    }
}
```

### Utilisation Automatique dans le ContrÃ´leur

```php
// Dans EmailTemplateController::store()
$template = EmailTemplate::create($validated);

// Gestion automatique du statut par dÃ©faut
if ($template->is_default) {
    $template->setAsDefault();
}

// Dans EmailTemplateController::update()
$emailTemplate->update($validated);

// Mise Ã  jour du statut si nÃ©cessaire
if ($emailTemplate->is_default) {
    $emailTemplate->setAsDefault();
}
```

### VÃ©rification de l'IntÃ©gritÃ©

```php
/**
 * VÃ©rifie l'intÃ©gritÃ© des templates par dÃ©faut
 * Commande artisan : php artisan templates:check-defaults
 */
public static function checkDefaultIntegrity()
{
    $categories = array_keys(self::CATEGORIES);
    $issues = [];

    foreach ($categories as $category) {
        $defaultCount = self::where('category', $category)
            ->where('is_default', true)
            ->count();

        if ($defaultCount === 0) {
            $issues[] = "Aucun template par dÃ©faut pour la catÃ©gorie : {$category}";
        } elseif ($defaultCount > 1) {
            $issues[] = "Plusieurs templates par dÃ©faut pour la catÃ©gorie : {$category} ({$defaultCount})";
        }
    }

    return $issues;
}
```

## ğŸ“Š Scopes AvancÃ©s et RequÃªtes OptimisÃ©es

### Scopes MÃ©tier SpÃ©cialisÃ©s

```php
/**
 * Scope pour rÃ©cupÃ©rer les templates actifs
 * UtilisÃ© systÃ©matiquement pour Ã©viter les templates dÃ©sactivÃ©s
 */
public function scopeActive($query)
{
    return $query->where('is_active', true);
}

/**
 * Scope pour filtrer par catÃ©gorie avec validation
 * Inclut une validation automatique de la catÃ©gorie
 */
public function scopeByCategory($query, $category)
{
    // Validation de la catÃ©gorie
    if (!in_array($category, array_keys(self::CATEGORIES))) {
        throw new \InvalidArgumentException("CatÃ©gorie invalide : {$category}");
    }

    return $query->where('category', $category);
}

/**
 * Scope pour rÃ©cupÃ©rer le template par dÃ©faut d'une catÃ©gorie
 * OptimisÃ© avec limite et tri pour performance
 */
public function scopeDefaultForCategory($query, $category)
{
    return $query->where('category', $category)
                 ->where('is_default', true)
                 ->where('is_active', true)
                 ->limit(1);
}
```

### Scopes AvancÃ©s pour Interface

```php
/**
 * Scope pour l'interface d'administration
 * Inclut compteurs et mÃ©tadonnÃ©es
 */
public function scopeForAdmin($query)
{
    return $query->select('*')
                 ->selectSub(
                     'SELECT COUNT(*) FROM email_templates et2 WHERE et2.category = email_templates.category',
                     'category_count'
                 )
                 ->with(['usageStats' => function($q) {
                     $q->selectRaw('COUNT(*) as usage_count');
                 }]);
}

/**
 * Scope pour sÃ©lection rapide (API)
 * OptimisÃ© pour les selects avec minimum de donnÃ©es
 */
public function scopeForSelection($query)
{
    return $query->select('id', 'name', 'sub_category', 'description', 'is_default')
                 ->where('is_active', true)
                 ->orderBy('is_default', 'desc')
                 ->orderBy('name');
}

/**
 * Scope de recherche textuelle
 * Recherche dans nom, description et contenu
 */
public function scopeSearch($query, $search)
{
    return $query->where(function($q) use ($search) {
        $q->where('name', 'like', "%{$search}%")
          ->orWhere('description', 'like', "%{$search}%")
          ->orWhere('subject', 'like', "%{$search}%")
          ->orWhere('body', 'like', "%{$search}%");
    });
}
```

### RequÃªtes Complexes OptimisÃ©es

```php
/**
 * RÃ©cupÃ©rer templates avec statistiques d'usage
 */
public static function getWithUsageStats($category = null)
{
    $query = self::query()
        ->leftJoin('email_logs', 'email_templates.id', '=', 'email_logs.template_id')
        ->select('email_templates.*')
        ->selectRaw('COUNT(email_logs.id) as usage_count')
        ->selectRaw('MAX(email_logs.created_at) as last_used')
        ->groupBy('email_templates.id');

    if ($category) {
        $query->byCategory($category);
    }

    return $query->orderBy('usage_count', 'desc')->get();
}

/**
 * RequÃªte pour dashboard avec mÃ©triques
 */
public static function getDashboardMetrics()
{
    return [
        'total_templates' => self::count(),
        'active_templates' => self::active()->count(),
        'templates_by_category' => self::groupBy('category')
            ->selectRaw('category, COUNT(*) as count')
            ->pluck('count', 'category'),
        'default_templates' => self::where('is_default', true)->count(),
        'most_used' => self::getWithUsageStats()->take(5)
    ];
}
```

## ğŸ·ï¸ Accessors AvancÃ©s et Formatage

### Accessors MÃ©tier

```php
/**
 * Accessor pour le nom formatÃ© de la catÃ©gorie
 * Inclut icÃ´ne et couleur pour l'interface
 */
protected function categoryName(): Attribute
{
    return Attribute::make(
        get: function () {
            $name = self::CATEGORIES[$this->category] ?? $this->category;
            $icon = $this->getCategoryIcon();
            return "{$icon} {$name}";
        }
    );
}

/**
 * Accessor pour le nom de la sous-catÃ©gorie avec description
 */
protected function subCategoryName(): Attribute
{
    return Attribute::make(
        get: function () {
            $name = self::SUB_CATEGORIES[$this->sub_category] ?? $this->sub_category;
            $description = $this->getSubCategoryDescription();
            return $description ? "{$name} - {$description}" : $name;
        }
    );
}

/**
 * Accessor pour le statut formatÃ©
 */
protected function statusFormatted(): Attribute
{
    return Attribute::make(
        get: function () {
            $status = $this->is_active ? 'Actif' : 'Inactif';
            $default = $this->is_default ? ' (Par dÃ©faut)' : '';
            return $status . $default;
        }
    );
}
```

### MÃ©thodes de Formatage

```php
/**
 * Obtient l'icÃ´ne associÃ©e Ã  la catÃ©gorie
 */
public function getCategoryIcon(): string
{
    $icons = [
        'envoi_initial' => 'ğŸ“¤',
        'rappel' => 'ğŸ””',
        'relance' => 'ğŸš€',
        'confirmation' => 'âœ…'
    ];

    return $icons[$this->category] ?? 'ğŸ“§';
}

/**
 * Obtient la couleur CSS pour la catÃ©gorie
 */
public function getCategoryColor(): string
{
    $colors = [
        'envoi_initial' => 'bg-blue-100 text-blue-800',
        'rappel' => 'bg-yellow-100 text-yellow-800',
        'relance' => 'bg-orange-100 text-orange-800',
        'confirmation' => 'bg-green-100 text-green-800'
    ];

    return $colors[$this->category] ?? 'bg-gray-100 text-gray-800';
}

/**
 * Obtient une description dÃ©taillÃ©e de la sous-catÃ©gorie
 */
public function getSubCategoryDescription(): string
{
    $descriptions = [
        'promotionnel' => 'Avec offre spÃ©ciale ou avantage',
        'concis_direct' => 'Court et sans fioritures',
        'standard_professionnel' => 'Ton professionnel classique',
        'detaille_etapes' => 'Processus Ã©tape par Ã©tape',
        'personnalise_chaleureux' => 'Approche humaine et chaleureuse',
        // ... autres descriptions
    ];

    return $descriptions[$this->sub_category] ?? '';
}
```

## ğŸ”„ MÃ©thodes Utilitaires AvancÃ©es

### Gestion des Sous-catÃ©gories

```php
/**
 * Obtient les sous-catÃ©gories disponibles pour une catÃ©gorie
 * Version amÃ©liorÃ©e avec validation et cache
 */
public static function getSubCategoriesForCategory($category): array
{
    // Cache pour Ã©viter la recomputation
    static $cache = [];
    
    if (isset($cache[$category])) {
        return $cache[$category];
    }

    $mapping = [
        'envoi_initial' => [
            'promotionnel', 'concis_direct', 'standard_professionnel',
            'detaille_etapes', 'personnalise_chaleureux'
        ],
        'rappel' => [
            'rappel_offre_speciale', 'rappel_date_expiration', 'rappel_standard'
        ],
        'relance' => [
            'suivi_standard', 'suivi_ajustements', 'suivi_feedback'
        ],
        'confirmation' => [
            'confirmation_infos', 'confirmation_etapes', 'confirmation_standard'
        ]
    ];

    $result = $mapping[$category] ?? [];
    $cache[$category] = $result;
    
    return $result;
}

/**
 * Valide la cohÃ©rence catÃ©gorie/sous-catÃ©gorie
 */
public function validateCategorySubCategory(): bool
{
    $validSubCategories = self::getSubCategoriesForCategory($this->category);
    return in_array($this->sub_category, $validSubCategories);
}
```

### Duplication et Templates

```php
/**
 * Duplique un template avec personnalisation
 */
public function duplicate($newName = null, $setAsActive = true): self
{
    $newTemplate = $this->replicate();
    $newTemplate->name = $newName ?? $this->name . ' (Copie)';
    $newTemplate->is_default = false; // Jamais par dÃ©faut lors de duplication
    $newTemplate->is_active = $setAsActive;
    $newTemplate->save();

    return $newTemplate;
}

/**
 * Exporte un template au format JSON
 */
public function exportToJson(): array
{
    return [
        'name' => $this->name,
        'category' => $this->category,
        'sub_category' => $this->sub_category,
        'subject' => $this->subject,
        'body' => $this->body,
        'description' => $this->description,
        'variables' => $this->variables,
        'exported_at' => now()->toISOString(),
        'version' => '1.0'
    ];
}
```

## ğŸ“ˆ Optimisations Performance

### Index et RequÃªtes

```php
// Index optimisÃ©s dans la migration
$table->index(['category', 'is_default']);          // Recherche template par dÃ©faut
$table->index(['category', 'sub_category']);        // Filtrage avancÃ©
$table->index(['is_active', 'category']);           // Templates actifs par catÃ©gorie
$table->index(['created_at']);                      // Tri chronologique
```

### Cache des Templates

```php
/**
 * Cache des templates par dÃ©faut pour performance
 */
public static function getCachedDefaultForCategory($category): ?self
{
    $cacheKey = "default_template_{$category}";
    
    return \Cache::remember($cacheKey, 3600, function () use ($category) {
        return self::defaultForCategory($category)->first();
    });
}

/**
 * Invalide le cache lors des modifications
 */
public function save(array $options = [])
{
    $result = parent::save($options);
    
    // Invalider le cache si template par dÃ©faut modifiÃ©
    if ($this->is_default) {
        \Cache::forget("default_template_{$this->category}");
    }
    
    return $result;
}
```

## ğŸ¯ Exemples d'Utilisation AvancÃ©e

### Workflow Complet d'Envoi

```php
// 1. RÃ©cupÃ©ration du template appropriÃ©
$template = EmailTemplate::active()
    ->byCategory('envoi_initial')
    ->defaultForCategory('envoi_initial')
    ->first();

// 2. PrÃ©paration des donnÃ©es contextuelles
$emailData = [
    'client_nom' => $devis->client->nom_complet,
    'entreprise_nom' => config('app.company_name'),
    'devis_numero' => $devis->numero_devis,
    'devis_montant' => $devis->montant_total_formatte,
    'devis_validite' => $devis->date_validite_formattee,
    'contact_email' => config('mail.from.address'),
    'contact_telephone' => config('app.phone')
];

// 3. Traitement du template
$processed = $template->processTemplate($emailData);

// 4. Envoi avec le contenu traitÃ©
Mail::to($devis->client->email)->send(
    new DevisClientMail($devis, $processed['subject'], $processed['body'])
);
```

### Gestion API pour Interface

```php
// API pour rÃ©cupÃ©ration dynamique des templates
Route::get('/api/templates/by-category', function (Request $request) {
    $category = $request->input('category');
    
    return EmailTemplate::active()
        ->byCategory($category)
        ->forSelection()
        ->get()
        ->map(function ($template) {
            return [
                'id' => $template->id,
                'name' => $template->name,
                'sub_category_name' => $template->sub_category_name,
                'is_default' => $template->is_default,
                'description' => $template->description
            ];
        });
});
```

## ğŸ“ Conclusion

Les mÃ©thodes mÃ©tier du systÃ¨me EmailTemplate offrent une **architecture robuste et flexible** pour la gestion avancÃ©e des templates d'emails. Les fonctionnalitÃ©s de traitement des variables, de gestion exclusive des templates par dÃ©faut, et les scopes optimisÃ©s permettent une utilisation simple et performante dans tous les contextes du Dashboard Madinia.

L'implÃ©mentation de ces mÃ©thodes garantit la **cohÃ©rence des donnÃ©es**, la **performance des requÃªtes**, et une **expÃ©rience utilisateur** fluide pour la gestion des communications par email. 